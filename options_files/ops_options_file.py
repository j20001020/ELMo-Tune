import os
import re
import configparser
from utils.constants import DEFAULT_OPTION_FILE_DIR, INITIAL_OPTIONS_FILE_NAME, OPTIONS_FILE_DIR
from utils.filter import BLACKLIST
from utils.parse import dict_to_configparser, configparser_to_string

def parse_llm_text_to_dict(llm_output_text):
    '''
    Function to parse the Gemini output text with filters

    Parameters:
    - llm_output_text (str): The output generated by Gemini

    Returns:
    - options_dict (dict): A dictionary containing the parsed data
    '''
    options_dict = {}

    for line in llm_output_text.split("\n"):
        # Ignore lines starting with '#' as they are comments
        if not line.startswith('#'):
            # Split the line at the first '=' and strip whitespace
            parts = line.split(':', 1)
            if len(parts) == 1:
                parts = line.split('=', 1)
            if len(parts) == 2:
                # filters options that start with { - k
                if '{' not in parts[1].strip():
                    # filters options that are in the blacklist
                    if parts[0].strip() not in BLACKLIST:
                        key, value = parts[0].strip(), parts[1].strip()
                        options_dict[key] = value

    return options_dict

def cleanup_options_file(llm_options_text):
    """
    Function to clean up the options file generated by Gemini
    - replace the values of the options in the original options file with the values generated by Gemini
        eliminate 2 secnarios:
        1. ```ini<code>```
        2. ```<code>...``` w/ multiple code blocks

    Parameters:
    - Gemini_options_text: string containing the options file generated by Gemini

    Returns:
    - config_string: string containing the options file in the original format
    """
    clean_output_dict = parse_option_file_to_dict(open(f"{OPTIONS_FILE_DIR}").read())

    # Parse the Gemini generated options
    llm_output_dict = parse_llm_text_to_dict(llm_options_text)

    # Update the original options with Gemini generated value
    for key, value in llm_output_dict.items():
        for internal_dict in clean_output_dict:
            if key in clean_output_dict[internal_dict]:
                clean_output_dict[internal_dict][key] = llm_output_dict[key]

    # Convert dictionary to configparser
    config_parser = dict_to_configparser(clean_output_dict)
    config_string = configparser_to_string(config_parser)

    # Save to a file
    with open(f"{OPTIONS_FILE_DIR}", "w") as file:
        file.write(config_string)
    return config_string

def get_initial_options_file():
    '''
    Get the initial options file

    Parameters:
    - None

    Returns:
    - options (str): The initial options file
    - reasoning (str): The reasoning behind the options file
    '''
    initial_options_file_path = os.path.join(DEFAULT_OPTION_FILE_DIR,
                                        INITIAL_OPTIONS_FILE_NAME)
    with open(initial_options_file_path, "r") as f:
        options = f.read()

    reasoning = f"Initial options file: {initial_options_file_path}"

    return options, reasoning


def parse_option_file_to_dict(option_file):
    '''
    Function to parse the given option file to a dictionary

    Parameters:
    - option_file (str): The path to the option file

    Returns:
    - parsed (dict): A dictionary containing the parsed data
    '''
    pat = re.compile("(.*)\s*([#].*)?")
    config = configparser.ConfigParser()
    config.read_string(option_file)
    parsed = {section: dict(config.items(section))
              for section in config.sections()}
    for section_name, section in parsed.items():
        for k, v in section.items():
            m = pat.match(v)
            section[k] = m[1]
    return parsed


